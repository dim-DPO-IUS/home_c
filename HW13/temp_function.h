#ifndef TEMP_FUNCTION_H
#define TEMP_FUNCTION_H
//
#include <limits.h> // Для INT_MAX и INT_MIN
#include <stdbool.h> // true, false
#include <stdint.h> // inttypes
#include <stdio.h>
#include <stdlib.h> // free, malloc ...
#include <string.h> // memset

/*----------------------------------------------------------------------------*/
/*                            ОПРЕДЕЛЕНИЯ ТИПОВ                               */
/*----------------------------------------------------------------------------*/

/**
 * @brief Структура для аргументов командной строки
 */
typedef struct cmd_args {
    const char* filename; ///< Имя входного файла
    uint8_t month; ///< Месяц для статистики (0 - не задан)
    uint16_t year; ///< Год для статистики (0 - не задан)
    uint8_t printdb; ///< Флаг вывода базы данных
    char sort;
} cmd_args;

/**
 * @brief Структура, представляющая данные датчика температуры.
 *
 * Используется для хранения метки времени и температуры.
 * Поддерживает только годы с 2000 по 2100, температуру в диапазоне -128..+127
 * °C.
 *
 * @note Для февраля високосные годы не проверяются автоматически.
 */
typedef struct sensor {
    uint16_t year; ///< Год (2000-2100)
    uint8_t month; ///< Месяц (1-12)
    uint8_t day; ///< День (1-31)
    uint8_t hour; ///< Часы (0-23)
    uint8_t minute; ///< Минуты (0-59)
    int8_t temperature; ///< Температура (°C)
} sensor;

/**
 * @brief Узел связного списка, содержащий данные датчика.
 *
 * Структура представляет собой узел односвязного списка, который хранит:
 * - Данные датчика (тип sensor)
 * - Указатель на следующий узел в списке
 *
 * @typedef list_node
 *
 * @var list_node::data
 * Данные датчика, хранящиеся в узле
 * @var list_node::next
 * Указатель на следующий узел списка. Если это последний узел, равен NULL.
 */
typedef struct node {
    sensor data; // Данные
    struct node* next; // Указатель на следующий элемент
} node;

/**
 * @brief Стурктура для записи статистики температуры
 *
 */
typedef struct temp_stats {
    uint16_t year;
    struct {
        float avg_temp; ///< Средняя температура
        int8_t min_temp; ///< Минимальная температура
        int8_t max_temp; ///< Максимальная температура
        int32_t total_temp; ///< Сумма температур для точного расчета
        int count; ///< Количество измерений
    } monthly[12], yearly;
} temp_stats;

/**
 * Статистика загрузки данных из CSV-файла
 */
typedef struct load_stats {
    char filename[256];
    size_t total_lines; ///< Всего строк в файле
    size_t empty_lines; ///< Пустых строк или комментариев
    size_t valid_records; ///< Успешно загруженных записей
    size_t invalid_format; ///< Строк с неверным форматом
    size_t invalid_values; ///< Строк с некорректными значениями
} load_stats;

/*----------------------------------------------------------------------------*/
/*                              CONSTANTS                                     */
/*----------------------------------------------------------------------------*/

/// Help message for command line interface
static const char HELP_MSG[]
    = "Использование: %s [опции]\n"
      "Опции:\n"
      " -h            Показать эту справку\n"
      " -f <file>     Указать входной CSV файл (обязательный)\n"
      " -m <month>    Статистика по месяцу (1-12)\n";
// " -y <year>     Статистика по году\n"
// " -s <sort>     Сортировка (t - температура, d - дата+время)\n";
// " -p <print>    Печать первых N записей\n"

/*----------------------------------------------------------------------------*/
/*                            СТЭК                                            */
/*----------------------------------------------------------------------------*/

/**
 * @brief Проверяет, пуст ли стек
 * @param top Указатель на вершину стека
 * @return true если стек пуст, false в противном случае
 */
bool is_empty(node* top);

/**
 * @brief Добавляет элемент в вершину стека
 * @param[in,out] top Указатель на указатель вершины стека
 * @param[in] data Данные датчика для добавления
 * @note Выделяет память под новый узел. При ошибке выводит "Memory error!"
 */
void push(node** top, sensor value);

/**
 * @brief Удаляет и возвращает элемент из вершины стека
 * @param[in,out] top Указатель на указатель вершины стека
 * @return Данные из удаленного узла. При пустом стеке возвращает структуру
 *         с нулевыми значениями и выводит "Stack underflow!"
 */
sensor pop(node** top);

/**
 * @brief Возвращает данные из вершины стека без удаления
 * @param top Указатель на вершину стека
 * @return Данные из вершины стека. При пустом стеке возвращает структуру
 *         с нулевыми значениями и выводит "Stack is empty!"
 */
sensor peek(node* top);

/**
 * @brief
 *
 */
void free_stack(node** top);

/**
 * @brief Выводит содержимое стека в консоль
 * @param top Указатель на вершину стека
 * @details Формат вывода для каждого элемента:
 *          "ГГГГ-ММ-ДД ЧЧ:ММ T°C". Для пустого стека выводит "Stack is empty."
 */
void print_stack(const node* top, int num);

/*----------------------------------------------------------------------------*/
/*                                ВВОД ДАННЫХ                                 */
/*----------------------------------------------------------------------------*/

/**
 * @brief Читает данные датчиков из CSV-файла и помещает их в стек
 * @param filename Имя CSV-файла для чтения
 * @param top Указатель на указатель вершины стека
 * @return true если файл успешно прочитан, false при ошибке
 */
size_t load_from_csv(
    const char* filename, node** top, char delimiter, load_stats* load_info);

/**
 * @brief
 *
 * @param load_info
 */
void print_load_stats(const load_stats* load_info);

/*----------------------------------------------------------------------------*/
/*                            СТАТИСТИКА                                      */
/*----------------------------------------------------------------------------*/

/**
 * @brief
 *
 * @param top
 */
temp_stats calculate_stats(node* top);

/**
 * @brief Вывод месячной статистики
 *
 * @param stats
 */
void print_monthly_stats(const temp_stats* stats, uint8_t month);

/**
 * @brief Вывод годовой статистики
 *
 * @param stats
 */
void print_yearly_stats(const temp_stats* stats);

/*----------------------------------------------------------------------------*/
/*                                  СОРТИРОВКА                                */
/*----------------------------------------------------------------------------*/

/**
 * @brief
 *
 * @param top
 * @param td 0: сортируем по температуре, 1: сортируем по дате
 */
void sort_stack(node** top, load_stats load_info, char td);

/*----------------------------------------------------------------------------*/
/*                                  КОМАНДНАЯ СТРОКА                          */
/*----------------------------------------------------------------------------*/

/**
 * @brief Парсинг аргументов командной строки
 * @param argc Количество аргументов
 * @param argv Массив аргументов
 * @param args Структура для результатов
 * @return 0 - успешно, 1 - вывод справки, -1 - ошибка
 */
int parse_arguments(int argc, char* argv[], cmd_args* args);

#endif // TEMP_FUNCTION_H