#include <stdio.h>
/*Упаковать 0 и 1
Написать функцию, которая сжимает серии массива, состоящего из единиц и нулей по
следующему принципу: например, массив [0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1]
преобразуется в [4,7,2,4] (т.к. начинается с нуля, то сразу записывается
количество элементов первой серии); а массив [1,1,1,0,0,0,0,0,0,0] преобразуется
в [0,3,7] (т.к. первая серия - это единицы, то первый элемент преобразованного
массива 0). Необходимо реализовать только одну функцию, всю программу загружать
не надо. Прототип функции: 

int compression(int a[], int b[], int N)

Формат входных данных: Функция принимает исходный массив a[] и сжимает в массив
b[], N - число элементов в массиве a[]. Формат результата: Функция возвращает
число элементов сжатого массива b[]*/

enum
{
    SIZE = 100
};

// Ввод массива с клавиатуры
void input_array(int arr[], int size);
// Печать массива
void print_array(int arr[], int size);
// Компрессия массива
int compression(int a[], int b[], int N);

//------------------------------------

int main(void)
{
    int a[SIZE] = {0};
    int b[SIZE] = {0};
    input_array(a, SIZE);
    int size_b = compression(a, b, SIZE);
    printf("%d\n", size_b);
    print_array(b, size_b);
    return 0;
}

//------------------------------------

void input_array(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        scanf("%d", &arr[i]);
    }
}

void print_array(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int compression(int a[], int b[], int N)
{
    int j = 0;

    a[0] ? b[++j]++ : b[j]++;

    for (int i = 0; i < N - 1; i++)
    {
        a[i] == a[i + 1] ? b[j]++ : b[++j]++;
    }
    return j + 1;
}

// Без тернарников. Эквивалент.
//-----------------------------------------
// int compression(int a[], int b[], int N)
// {
//     int j = 0;

//     if (a[0]) {
//         j++;
//         b[j]++;
//     } else {
//         b[j]++;
//     }

//     for (int i = 0; i < N - 1; i++) {
//         if (a[i] == a[i + 1]) {
//             b[j]++;
//         } else {
//             j++;
//             b[j]++;
//         }
//     }
//     return j + 1;
// }
